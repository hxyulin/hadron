use core::convert::AsRef;
use serde::de::DeserializeOwned;
use serde_derive::{Deserialize, Serialize};
use std::{collections::HashMap, path::Path};

/// A node in the configuration tree.
///
/// This is used to represent the configuration tree, according to how it looks in the file system.
#[derive(Debug, Clone)]
pub struct ConfigNode {
    /// The last part of the path.
    /// This is used as the prefix if the prefix is not set.
    path: String,
    /// The configuration options.
    config: RawConfig,
    /// The children of this node.
    children: Vec<ConfigNode>,
}

impl ConfigNode {
    /// Creates a new tree from the given directory, returning None if there is no `Kconfig` file.
    pub fn from_fs<P: AsRef<Path>>(path: P) -> Option<Self> {
        // We parse the config, and then call the function recursively for the children.
        let config_file = path.as_ref().join("kconfig.toml");
        if !config_file.exists() {
            return None;
        }

        let config: RawConfig =
            toml::from_str(&std::fs::read_to_string(config_file).expect("Failed to read config file"))
                .expect("Failed to parse config file");

        let mut children = Vec::new();
        for include in &config.include {
            let child = path.as_ref().join(include);
            assert!(child.exists(), "Include {} does not exist", child.display());
            let mut child = Self::from_fs(child).expect("Failed to parse include");
            child.path = include.clone();
            children.push(child);
        }

        Some(Self {
            path: String::new(),
            config,
            children,
        })
    }

    pub fn flatten(&self) -> Config {
        let mut config = Config::default();
        self.flatten_recursive("", &mut config);
        config
    }

    fn flatten_recursive(&self, prefix: &str, config: &mut Config) {
        // So if the path is empty, we just use the prefix.
        let prefix = if prefix.is_empty() {
            prefix.to_string()
        } else {
            format!("{}{}.", prefix, self.path)
        };
        for child in &self.children {
            child.flatten_recursive(&prefix, config);
        }

        for (name, option) in &self.config.options {
            let name = format!("{}{}", prefix, name);
            let option = ConfigOption {
                name: name.clone(),
                description: option.description.clone(),
                depends: option.depends.clone(),
                type_: option.type_.clone(),
                value: ConfigValue::from_value(option.type_.clone(), option.default.clone()),
            };
            config.options.insert(name, option);
        }
    }
}

/// The kernel configuration.
///
/// This is a flattened representation of the configuration tree.
#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    /// The options of the config, with their full name (with the prefix).
    #[serde(rename = "option")]
    pub options: HashMap<String, ConfigOption>,
}

impl Config {
    pub fn from_root<P: AsRef<Path>>(path: P) -> Self {
        let node = ConfigNode::from_fs(path).expect("Failed to parse config");
        node.flatten()
    }

    pub fn serialize<P: AsRef<Path>>(&self, path: P) -> Result<(), Box<dyn std::error::Error>> {
        use std::io::Write;
        let mut file = std::fs::File::create(path)?;
        file.write_all(b"# This file is automatically generated by the kconfig crate\n\n")?;
        file.write_all(toml::to_string(&self)?.as_bytes())?;
        Ok(())
    }

    pub fn deserialize<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {
        use std::io::Read;
        let mut file = std::fs::File::open(path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        Ok(toml::from_str(&contents)?)
    }

    /// Generic extractor: panics if the conversion fails.
    fn expect_type<T>(v: &ConfigValue) -> T
    where
        T: TryFrom<ConfigValue> + DeserializeOwned,
        <T as TryFrom<ConfigValue>>::Error: std::fmt::Debug,
    {
        // clone the Value, attempt conversion, unwrap to panic on error
        v.clone().try_into().unwrap()
    }

    pub fn get<T>(&self, key: &str) -> Option<T>
    where
        T: TryFrom<ConfigValue> + DeserializeOwned,
        <T as TryFrom<ConfigValue>>::Error: std::fmt::Debug,
    {
        self.options.get(key).map(|v| Self::expect_type(&v.value))
    }

    pub fn get_mut(&mut self, key: &str) -> Option<&mut ConfigOption> {
        self.options.get_mut(key)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ConfigOption {
    pub name: String,
    pub description: String,
    pub depends: Vec<String>,
    pub type_: ConfigType,
    pub value: ConfigValue,
}

impl Into<bool> for ConfigValue {
    fn into(self) -> bool {
        match self {
            ConfigValue::Bool(b) => b,
            _ => panic!("Invalid value for bool"),
        }
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum ConfigType {
    #[serde(rename = "bool")]
    Bool,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ConfigValue {
    Bool(bool),
}

impl ConfigValue {
    fn as_value(&self) -> toml::Value {
        match self {
            ConfigValue::Bool(b) => toml::Value::Boolean(*b),
        }
    }
}

impl serde::Serialize for ConfigValue {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        // We create a toml::Value, and then serialize that.
        let value = self.as_value();
        value.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for ConfigValue {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        // We deserialize into a toml::Value, and then convert that.
        let value = toml::Value::deserialize(deserializer)?;
        Ok(Self::from_untyped_value(value))
    }
}

impl ConfigValue {
    pub fn from_untyped_value(value: toml::Value) -> Self {
        match value {
            toml::Value::Boolean(b) => ConfigValue::Bool(b),
            _ => panic!("Invalid value for bool"),
        }
    }

    pub fn from_value(type_: ConfigType, value: toml::Value) -> Self {
        match type_ {
            ConfigType::Bool => match value {
                toml::Value::Boolean(b) => ConfigValue::Bool(b),
                _ => panic!("Invalid value for bool"),
            },
        }
    }

    pub fn as_bool(&self) -> bool {
        match self {
            ConfigValue::Bool(b) => *b,
            _ => panic!("Not a bool"),
        }
    }
}

/// An instance of the kernel configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawConfig {
    /// A list of nested directories to include.
    #[serde(default)]
    include: Vec<String>,
    #[serde(default)]
    prefix: Option<String>,
    /// The options of the config, using [option.<name>] as the key.
    #[serde(default, rename = "option")]
    options: HashMap<String, RawConfigOption>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawConfigOption {
    description: String,
    depends: Vec<String>,
    #[serde(rename = "type")]
    type_: ConfigType,
    default: toml::Value,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse() {
        let root = tempfile::tempdir().unwrap().into_path().join("test-config");
        std::fs::create_dir(&root).unwrap();
        let root_config = root.join("kconfig.toml");
        std::fs::write(
            &root_config,
            r#"
prefix = "test"
include = ["child"]

[option.test]
description = "Test option"
depends = ["test.dep"]
type = "bool"
default = false
"#,
        )
        .unwrap();

        let child_dir = root.join("child");
        std::fs::create_dir(&child_dir).unwrap();
        let child_config = child_dir.join("kconfig.toml");
        std::fs::write(
            &child_config,
            r#"
prefix = "child"

[option.test1]
description = "Test option"
depends = ["test2"]
type = "bool"
default = true
"#,
        )
        .unwrap();

        let config = ConfigNode::from_fs(root).unwrap();
        assert_eq!(config.path, "");
        assert_eq!(config.config.prefix, Some("test".to_string()));
        assert_eq!(
            config.config.options.get("test").unwrap().depends,
            vec!["test.dep".to_string()]
        );
        assert_eq!(config.children.len(), 1);
        let child = config.children.get(0).unwrap();
        assert_eq!(child.path, "child");
        assert_eq!(child.config.prefix, Some("child".to_string()));
        assert_eq!(
            child.config.options.get("test1").unwrap().depends,
            vec!["test2".to_string()]
        );
    }

    #[test]
    fn test_flatten() {
        let options = HashMap::from([
            (
                "test1".to_string(),
                RawConfigOption {
                    description: "Test option".to_string(),
                    depends: vec![],
                    type_: ConfigType::Bool,
                    default: toml::Value::Boolean(true),
                },
            ),
            (
                "test2".to_string(),
                RawConfigOption {
                    description: "Test option".to_string(),
                    depends: vec![],
                    type_: ConfigType::Bool,
                    default: toml::Value::Boolean(false),
                },
            ),
        ]);
        let node = ConfigNode {
            path: "child2".to_string(),
            config: RawConfig {
                include: vec![],
                prefix: Some("child2".to_string()),
                options: options.clone(),
            },
            children: Vec::new(),
        };

        let options = HashMap::from([(
            "test".to_string(),
            RawConfigOption {
                description: "Test option".to_string(),
                depends: vec!["child2.test1".to_string()],
                type_: ConfigType::Bool,
                default: toml::Value::Boolean(false),
            },
        )]);
        let node = ConfigNode {
            path: "child1".to_string(),
            config: RawConfig {
                include: vec![],
                prefix: Some("child1".to_string()),
                options,
            },
            children: vec![node],
        };

        let node = ConfigNode {
            path: "".to_string(),
            config: RawConfig {
                include: vec![],
                prefix: None,
                options: HashMap::new(),
            },
            children: vec![node],
        };

        let config = node.flatten();
        assert_eq!(config.options.len(), 3);
        assert!(config.options.get("child1.test").is_some());
        assert!(config.options.get("child1.child2.test1").is_some());
        assert!(config.options.get("child1.child2.test2").is_some());
    }

    #[test]
    fn test_write_config() {
        let options = Config {
            options: HashMap::from([
                (
                    "test1".to_string(),
                    ConfigOption {
                        name: "test1".to_string(),
                        description: "Test option".to_string(),
                        depends: vec![],
                        type_: ConfigType::Bool,
                        value: ConfigValue::Bool(true),
                    },
                ),
                (
                    "test2".to_string(),
                    ConfigOption {
                        name: "test2".to_string(),
                        description: "Test option".to_string(),
                        depends: vec![],
                        type_: ConfigType::Bool,
                        value: ConfigValue::Bool(false),
                    },
                ),
            ]),
        };
        let tmpfile = tempfile::NamedTempFile::new().unwrap();
        options.serialize(tmpfile.path()).unwrap();
        let new_config = Config::deserialize(tmpfile.path()).unwrap();
        assert_eq!(new_config.options, options.options);
    }
}
